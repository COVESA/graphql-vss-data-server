/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.2.0.v202012010850.
* Used org.franca.core 0.13.1.201807231814.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#ifndef V1_ORG_GENIVI_VEHICLE_PLAYGROUND_Playground_PROXY_HPP_
#define V1_ORG_GENIVI_VEHICLE_PLAYGROUND_Playground_PROXY_HPP_

#include <v1/org/genivi/vehicle/playground/PlaygroundProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#define HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE
#endif

#include <CommonAPI/AttributeExtension.hpp>
#include <CommonAPI/Factory.hpp>

#if defined (HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE)
#undef COMMONAPI_INTERNAL_COMPILATION
#undef HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE
#endif

namespace v1 {
namespace org {
namespace genivi {
namespace vehicle {
namespace playground {

template <typename ... _AttributeExtensions>
class PlaygroundProxy
    : virtual public Playground,
      virtual public PlaygroundProxyBase,
      virtual public _AttributeExtensions... {
public:
    PlaygroundProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~PlaygroundProxy();

    typedef Playground InterfaceType;


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

    virtual std::future<void> getCompletionFuture();

    /*
     * description: 
     * Current consumption in liters per 100 km
     */
    /**
     * Returns the wrapper class that provides access to the attribute consumption.
     */
    virtual ConsumptionAttribute& getConsumptionAttribute() {
        return delegate_->getConsumptionAttribute();
    }
    /*
     * description: 
     * Capacity of the fuel tank in milliliters
     * Unit: ml
     */
    /**
     * Returns the wrapper class that provides access to the attribute capacity.
     */
    virtual CapacityAttribute& getCapacityAttribute() {
        return delegate_->getCapacityAttribute();
    }
    /*
     * description: 
     * Current volume of fuel in the tank in liters
     */
    /**
     * Returns the wrapper class that provides access to the attribute volume.
     */
    virtual VolumeAttribute& getVolumeAttribute() {
        return delegate_->getVolumeAttribute();
    }
    /*
     * description: 
     * Engine speed measured as rotations per minute
     */
    /**
     * Returns the wrapper class that provides access to the attribute engineSpeed.
     */
    virtual EngineSpeedAttribute& getEngineSpeedAttribute() {
        return delegate_->getEngineSpeedAttribute();
    }
    /*
     * description: 
     * Current gear
     */
    /**
     * Returns the wrapper class that provides access to the attribute currentGear.
     */
    virtual CurrentGearAttribute& getCurrentGearAttribute() {
        return delegate_->getCurrentGearAttribute();
    }
    /*
     * description: 
     * Is reverse gear selected
     */
    /**
     * Returns the wrapper class that provides access to the attribute isReverseGearOn.
     */
    virtual IsReverseGearOnAttribute& getIsReverseGearOnAttribute() {
        return delegate_->getIsReverseGearOnAttribute();
    }
    /*
     * description: 
     * Drive Type
     */
    /**
     * Returns the wrapper class that provides access to the attribute drivePowerTransmission.
     */
    virtual DrivePowerTransmissionAttribute& getDrivePowerTransmissionAttribute() {
        return delegate_->getDrivePowerTransmissionAttribute();
    }
    /*
     * description: 
     * Report the opening status for each door
     */
    /**
     * Returns the wrapper class that provides access to the attribute doorsOpeningStatus.
     */
    virtual DoorsOpeningStatusAttribute& getDoorsOpeningStatusAttribute() {
        return delegate_->getDoorsOpeningStatusAttribute();
    }
    /*
     * description: 
     * Describes the seat heating status set by the user.
     * index 0 == Driver
     * index 1 == Co-Driver
     * index 3 == Passenger in the second row on the Driver side
     * index 4 == Passenger in the second row on the Middle side
     * index 5 == Passenger in the second row on the Co-driver side
     * index 6 == Passenger in the third row on the Driver side
     * index 7 == Passenger in the third row on the Co-driver side
     * Just for demo the some SomeIP service will return values for Driver and Co-Driver only
     */
    /**
     * Returns the wrapper class that provides access to the attribute seatHeatingStatus.
     */
    virtual SeatHeatingStatusAttribute& getSeatHeatingStatusAttribute() {
        return delegate_->getSeatHeatingStatusAttribute();
    }
    /*
     * description: 
     * Describes the seat heating level selected by the user
     * index 0 == Driver
     * index 1 == Co-Driver
     * index 3 == Passenger in the second row on the Driver side
     * index 4 == Passenger in the second row on the Middle side
     * index 5 == Passenger in the second row on the Co-driver side
     * index 6 == Passenger in the third row on the Driver side
     * index 7 == Passenger in the third row on the Co-driver side
     * Just for demo the some SomeIP service will return values for Driver and Co-Driver only
     */
    /**
     * Returns the wrapper class that provides access to the attribute seatHeatingLevel.
     */
    virtual SeatHeatingLevelAttribute& getSeatHeatingLevelAttribute() {
        return delegate_->getSeatHeatingLevelAttribute();
    }
    /**
     * description: 
     * Trigger tire pressure initialization process
     * Calls initTirePressureCalibration with synchronous semantics.
     *
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void initTirePressureCalibration(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls initTirePressureCalibration with asynchronous semantics.
     *
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> initTirePressureCalibrationAsync(InitTirePressureCalibrationAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: 
     * Trigger the change on doors opening state
     * Calls changeDoorsState with synchronous semantics.
     *
     * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void changeDoorsState(::org::genivi::vehicle::playgroundtypes::PlaygroundTypes::CarDoorsCommand _commands, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls changeDoorsState with asynchronous semantics.
     *
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> changeDoorsStateAsync(const ::org::genivi::vehicle::playgroundtypes::PlaygroundTypes::CarDoorsCommand &_commands, ChangeDoorsStateAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /*
     * description: 
     * Vehicle position data provided by GPS
     */
    /**
     * Returns the wrapper class that provides access to the broadcast vehiclePosition.
     */
    virtual VehiclePositionEvent& getVehiclePositionEvent() {
        return delegate_->getVehiclePositionEvent();
    }
    /*
     * description: 
     * The current tank volume
     */
    /**
     * Returns the wrapper class that provides access to the broadcast currentTankVolume.
     */
    virtual CurrentTankVolumeEvent& getCurrentTankVolumeEvent() {
        return delegate_->getCurrentTankVolumeEvent();
    }



 private:
    std::shared_ptr< PlaygroundProxyBase> delegate_;
};

typedef PlaygroundProxy<> PlaygroundProxyDefault;

namespace PlaygroundExtensions {
    /*
     * description: 
     * Current consumption in liters per 100 km
     */
    template <template <typename > class _ExtensionType>
    class ConsumptionAttributeExtension {
     public:
        typedef _ExtensionType< PlaygroundProxyBase::ConsumptionAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension< PlaygroundProxyBase::ConsumptionAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    
        ConsumptionAttributeExtension(PlaygroundProxyBase& proxy): attributeExtension_(proxy.getConsumptionAttribute()) {
        }
    
        inline extension_type& getConsumptionAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /*
     * description: 
     * Capacity of the fuel tank in milliliters
     * Unit: ml
     */
    template <template <typename > class _ExtensionType>
    class CapacityAttributeExtension {
     public:
        typedef _ExtensionType< PlaygroundProxyBase::CapacityAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension< PlaygroundProxyBase::CapacityAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    
        CapacityAttributeExtension(PlaygroundProxyBase& proxy): attributeExtension_(proxy.getCapacityAttribute()) {
        }
    
        inline extension_type& getCapacityAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /*
     * description: 
     * Current volume of fuel in the tank in liters
     */
    template <template <typename > class _ExtensionType>
    class VolumeAttributeExtension {
     public:
        typedef _ExtensionType< PlaygroundProxyBase::VolumeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension< PlaygroundProxyBase::VolumeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    
        VolumeAttributeExtension(PlaygroundProxyBase& proxy): attributeExtension_(proxy.getVolumeAttribute()) {
        }
    
        inline extension_type& getVolumeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /*
     * description: 
     * Engine speed measured as rotations per minute
     */
    template <template <typename > class _ExtensionType>
    class EngineSpeedAttributeExtension {
     public:
        typedef _ExtensionType< PlaygroundProxyBase::EngineSpeedAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension< PlaygroundProxyBase::EngineSpeedAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    
        EngineSpeedAttributeExtension(PlaygroundProxyBase& proxy): attributeExtension_(proxy.getEngineSpeedAttribute()) {
        }
    
        inline extension_type& getEngineSpeedAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /*
     * description: 
     * Current gear
     */
    template <template <typename > class _ExtensionType>
    class CurrentGearAttributeExtension {
     public:
        typedef _ExtensionType< PlaygroundProxyBase::CurrentGearAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension< PlaygroundProxyBase::CurrentGearAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    
        CurrentGearAttributeExtension(PlaygroundProxyBase& proxy): attributeExtension_(proxy.getCurrentGearAttribute()) {
        }
    
        inline extension_type& getCurrentGearAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /*
     * description: 
     * Is reverse gear selected
     */
    template <template <typename > class _ExtensionType>
    class IsReverseGearOnAttributeExtension {
     public:
        typedef _ExtensionType< PlaygroundProxyBase::IsReverseGearOnAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension< PlaygroundProxyBase::IsReverseGearOnAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    
        IsReverseGearOnAttributeExtension(PlaygroundProxyBase& proxy): attributeExtension_(proxy.getIsReverseGearOnAttribute()) {
        }
    
        inline extension_type& getIsReverseGearOnAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /*
     * description: 
     * Drive Type
     */
    template <template <typename > class _ExtensionType>
    class DrivePowerTransmissionAttributeExtension {
     public:
        typedef _ExtensionType< PlaygroundProxyBase::DrivePowerTransmissionAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension< PlaygroundProxyBase::DrivePowerTransmissionAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    
        DrivePowerTransmissionAttributeExtension(PlaygroundProxyBase& proxy): attributeExtension_(proxy.getDrivePowerTransmissionAttribute()) {
        }
    
        inline extension_type& getDrivePowerTransmissionAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /*
     * description: 
     * Report the opening status for each door
     */
    template <template <typename > class _ExtensionType>
    class DoorsOpeningStatusAttributeExtension {
     public:
        typedef _ExtensionType< PlaygroundProxyBase::DoorsOpeningStatusAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension< PlaygroundProxyBase::DoorsOpeningStatusAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    
        DoorsOpeningStatusAttributeExtension(PlaygroundProxyBase& proxy): attributeExtension_(proxy.getDoorsOpeningStatusAttribute()) {
        }
    
        inline extension_type& getDoorsOpeningStatusAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /*
     * description: 
     * Describes the seat heating status set by the user.
     * index 0 == Driver
     * index 1 == Co-Driver
     * index 3 == Passenger in the second row on the Driver side
     * index 4 == Passenger in the second row on the Middle side
     * index 5 == Passenger in the second row on the Co-driver side
     * index 6 == Passenger in the third row on the Driver side
     * index 7 == Passenger in the third row on the Co-driver side
     * Just for demo the some SomeIP service will return values for Driver and Co-Driver only
     */
    template <template <typename > class _ExtensionType>
    class SeatHeatingStatusAttributeExtension {
     public:
        typedef _ExtensionType< PlaygroundProxyBase::SeatHeatingStatusAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension< PlaygroundProxyBase::SeatHeatingStatusAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    
        SeatHeatingStatusAttributeExtension(PlaygroundProxyBase& proxy): attributeExtension_(proxy.getSeatHeatingStatusAttribute()) {
        }
    
        inline extension_type& getSeatHeatingStatusAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /*
     * description: 
     * Describes the seat heating level selected by the user
     * index 0 == Driver
     * index 1 == Co-Driver
     * index 3 == Passenger in the second row on the Driver side
     * index 4 == Passenger in the second row on the Middle side
     * index 5 == Passenger in the second row on the Co-driver side
     * index 6 == Passenger in the third row on the Driver side
     * index 7 == Passenger in the third row on the Co-driver side
     * Just for demo the some SomeIP service will return values for Driver and Co-Driver only
     */
    template <template <typename > class _ExtensionType>
    class SeatHeatingLevelAttributeExtension {
     public:
        typedef _ExtensionType< PlaygroundProxyBase::SeatHeatingLevelAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension< PlaygroundProxyBase::SeatHeatingLevelAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    
        SeatHeatingLevelAttributeExtension(PlaygroundProxyBase& proxy): attributeExtension_(proxy.getSeatHeatingLevelAttribute()) {
        }
    
        inline extension_type& getSeatHeatingLevelAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace PlaygroundExtensions

//
// PlaygroundProxy Implementation
//
template <typename ... _AttributeExtensions>
PlaygroundProxy<_AttributeExtensions...>::PlaygroundProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast< PlaygroundProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast< PlaygroundProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
PlaygroundProxy<_AttributeExtensions...>::~PlaygroundProxy() {
}

/*
 * description: 
 * Trigger tire pressure initialization process
 */
template <typename ... _AttributeExtensions>
void PlaygroundProxy<_AttributeExtensions...>::initTirePressureCalibration(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->initTirePressureCalibration(_internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PlaygroundProxy<_AttributeExtensions...>::initTirePressureCalibrationAsync(InitTirePressureCalibrationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->initTirePressureCalibrationAsync(_callback, _info);
}
/*
 * description: 
 * Trigger the change on doors opening state
 */
template <typename ... _AttributeExtensions>
void PlaygroundProxy<_AttributeExtensions...>::changeDoorsState(::org::genivi::vehicle::playgroundtypes::PlaygroundTypes::CarDoorsCommand _commands, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->changeDoorsState(_commands, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PlaygroundProxy<_AttributeExtensions...>::changeDoorsStateAsync(const ::org::genivi::vehicle::playgroundtypes::PlaygroundTypes::CarDoorsCommand &_commands, ChangeDoorsStateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->changeDoorsStateAsync(_commands, _callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &PlaygroundProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool PlaygroundProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool PlaygroundProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& PlaygroundProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& PlaygroundProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


template <typename ... _AttributeExtensions>
std::future<void> PlaygroundProxy<_AttributeExtensions...>::getCompletionFuture() {
    return delegate_->getCompletionFuture();
}

} // namespace playground
} // namespace vehicle
} // namespace genivi
} // namespace org
} // namespace v1

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyHelper< ::v1::org::genivi::vehicle::playground::PlaygroundProxy,
    _AttributeExtension> {
    typedef typename ::v1::org::genivi::vehicle::playground::PlaygroundProxy<
            ::v1::org::genivi::vehicle::playground::PlaygroundExtensions::ConsumptionAttributeExtension<_AttributeExtension>, 
            ::v1::org::genivi::vehicle::playground::PlaygroundExtensions::CapacityAttributeExtension<_AttributeExtension>, 
            ::v1::org::genivi::vehicle::playground::PlaygroundExtensions::VolumeAttributeExtension<_AttributeExtension>, 
            ::v1::org::genivi::vehicle::playground::PlaygroundExtensions::EngineSpeedAttributeExtension<_AttributeExtension>, 
            ::v1::org::genivi::vehicle::playground::PlaygroundExtensions::CurrentGearAttributeExtension<_AttributeExtension>, 
            ::v1::org::genivi::vehicle::playground::PlaygroundExtensions::IsReverseGearOnAttributeExtension<_AttributeExtension>, 
            ::v1::org::genivi::vehicle::playground::PlaygroundExtensions::DrivePowerTransmissionAttributeExtension<_AttributeExtension>, 
            ::v1::org::genivi::vehicle::playground::PlaygroundExtensions::DoorsOpeningStatusAttributeExtension<_AttributeExtension>, 
            ::v1::org::genivi::vehicle::playground::PlaygroundExtensions::SeatHeatingStatusAttributeExtension<_AttributeExtension>, 
            ::v1::org::genivi::vehicle::playground::PlaygroundExtensions::SeatHeatingLevelAttributeExtension<_AttributeExtension>
    > class_t;
};
}


// Compatibility
namespace v1_0 = v1;

#endif // V1_ORG_GENIVI_VEHICLE_PLAYGROUND_Playground_PROXY_HPP_
