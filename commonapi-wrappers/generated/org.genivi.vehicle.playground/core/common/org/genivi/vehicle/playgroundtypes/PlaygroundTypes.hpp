/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.2.0.v202012010850.
* Used org.franca.core 0.13.1.201807231814.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#ifndef ORG_GENIVI_VEHICLE_PLAYGROUNDTYPES_Playground_Types_HPP_
#define ORG_GENIVI_VEHICLE_PLAYGROUNDTYPES_Playground_Types_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#define HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>

#if defined (HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE)
#undef COMMONAPI_INTERNAL_COMPILATION
#undef HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE
#endif

namespace org {
namespace genivi {
namespace vehicle {
namespace playgroundtypes {

struct PlaygroundTypes {
    
    struct Gear : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            /*
             * description: 
             * The unit is being initialized
             */
            UNKNOWN_GEAR = 0,
            /*
             * description: 
             * No gear is selected.
             */
            NEUTRAL = 1,
            /*
             * description: 
             * First gear is selected.
             */
            FIRST_GEAR = 2,
            /*
             * description: 
             * Second gear is selected.
             */
            SECOND_GEAR = 3,
            /*
             * description: 
             * Third gear is selected.
             */
            THIRD_GEAR = 4,
            /*
             * description: 
             * Fourth gear is selected.
             */
            FOURTH_GEAR = 5,
            /*
             * description: 
             * Fifth gear is selected.
             */
            FIFTH_GEAR = 6,
            /*
             * description: 
             * Sixth gear is selected.
             */
            SIXTH_GEAR = 7,
            /*
             * description: 
             * The gear sensor is reporting an error
             */
            ERROR = 8
        };
    
        Gear()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::UNKNOWN_GEAR)) {}
        Gear(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::UNKNOWN_GEAR):
                case static_cast< uint8_t>(Literal::NEUTRAL):
                case static_cast< uint8_t>(Literal::FIRST_GEAR):
                case static_cast< uint8_t>(Literal::SECOND_GEAR):
                case static_cast< uint8_t>(Literal::THIRD_GEAR):
                case static_cast< uint8_t>(Literal::FOURTH_GEAR):
                case static_cast< uint8_t>(Literal::FIFTH_GEAR):
                case static_cast< uint8_t>(Literal::SIXTH_GEAR):
                case static_cast< uint8_t>(Literal::ERROR):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const Gear &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const Gear &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const Gear &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const Gear &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const Gear &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const Gear &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint8_t>(Literal::UNKNOWN_GEAR): return "UNKNOWN_GEAR";
            case static_cast< uint8_t>(Literal::NEUTRAL): return "NEUTRAL";
            case static_cast< uint8_t>(Literal::FIRST_GEAR): return "FIRST_GEAR";
            case static_cast< uint8_t>(Literal::SECOND_GEAR): return "SECOND_GEAR";
            case static_cast< uint8_t>(Literal::THIRD_GEAR): return "THIRD_GEAR";
            case static_cast< uint8_t>(Literal::FOURTH_GEAR): return "FOURTH_GEAR";
            case static_cast< uint8_t>(Literal::FIFTH_GEAR): return "FIFTH_GEAR";
            case static_cast< uint8_t>(Literal::SIXTH_GEAR): return "SIXTH_GEAR";
            case static_cast< uint8_t>(Literal::ERROR): return "ERROR";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct DriveType : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            /*
             * description: 
             * Power transmission drive on front axle
             */
            FRONT_WHEEL_DRIVE = 1,
            /*
             * description: 
             * Power transmission drive on rear axle
             */
            REAR_WHEEL_DRIVE = 2,
            /*
             * description: 
             * Power transmission drive on front and rear axles
             */
            ALL_WHEEL_DRIVE = 3
        };
    
        DriveType()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::FRONT_WHEEL_DRIVE)) {}
        DriveType(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::FRONT_WHEEL_DRIVE):
                case static_cast< uint8_t>(Literal::REAR_WHEEL_DRIVE):
                case static_cast< uint8_t>(Literal::ALL_WHEEL_DRIVE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const DriveType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const DriveType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const DriveType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const DriveType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const DriveType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const DriveType &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint8_t>(Literal::FRONT_WHEEL_DRIVE): return "FRONT_WHEEL_DRIVE";
            case static_cast< uint8_t>(Literal::REAR_WHEEL_DRIVE): return "REAR_WHEEL_DRIVE";
            case static_cast< uint8_t>(Literal::ALL_WHEEL_DRIVE): return "ALL_WHEEL_DRIVE";
            default: return "UNDEFINED";
            }
        }
    };
    struct GPSDate : CommonAPI::Struct< uint8_t, uint8_t, uint16_t> {
    
        GPSDate()
        {
            std::get< 0>(values_) = 0u;
            std::get< 1>(values_) = 0u;
            std::get< 2>(values_) = 0u;
        }
        GPSDate(const uint8_t &_day, const uint8_t &_month, const uint16_t &_year)
        {
            std::get< 0>(values_) = _day;
            std::get< 1>(values_) = _month;
            std::get< 2>(values_) = _year;
        }
        /*
         * description: 
         * The current day provided by GPS
         */
        inline const uint8_t &getDay() const { return std::get< 0>(values_); }
        inline void setDay(const uint8_t &_value) { std::get< 0>(values_) = _value; }
        /*
         * description: 
         * The current month provided by GPS
         */
        inline const uint8_t &getMonth() const { return std::get< 1>(values_); }
        inline void setMonth(const uint8_t &_value) { std::get< 1>(values_) = _value; }
        /*
         * description: 
         * The current year provided by GPS
         */
        inline const uint16_t &getYear() const { return std::get< 2>(values_); }
        inline void setYear(const uint16_t &_value) { std::get< 2>(values_) = _value; }
        inline bool operator==(const GPSDate& _other) const {
        return (getDay() == _other.getDay() && getMonth() == _other.getMonth() && getYear() == _other.getYear());
        }
        inline bool operator!=(const GPSDate &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct GPSTime : CommonAPI::Struct< uint8_t, uint8_t, uint8_t> {
    
        GPSTime()
        {
            std::get< 0>(values_) = 0u;
            std::get< 1>(values_) = 0u;
            std::get< 2>(values_) = 0u;
        }
        GPSTime(const uint8_t &_second, const uint8_t &_minute, const uint8_t &_hour)
        {
            std::get< 0>(values_) = _second;
            std::get< 1>(values_) = _minute;
            std::get< 2>(values_) = _hour;
        }
        /*
         * description: 
         * Time seconds provided by GPS
         */
        inline const uint8_t &getSecond() const { return std::get< 0>(values_); }
        inline void setSecond(const uint8_t &_value) { std::get< 0>(values_) = _value; }
        /*
         * description: 
         * Time minutes provided by GPS
         */
        inline const uint8_t &getMinute() const { return std::get< 1>(values_); }
        inline void setMinute(const uint8_t &_value) { std::get< 1>(values_) = _value; }
        /*
         * description: 
         * Time hours provided by GPS
         */
        inline const uint8_t &getHour() const { return std::get< 2>(values_); }
        inline void setHour(const uint8_t &_value) { std::get< 2>(values_) = _value; }
        inline bool operator==(const GPSTime& _other) const {
        return (getSecond() == _other.getSecond() && getMinute() == _other.getMinute() && getHour() == _other.getHour());
        }
        inline bool operator!=(const GPSTime &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct GPSPosition : CommonAPI::Struct< double, double, double> {
    
        GPSPosition()
        {
            std::get< 0>(values_) = 0.0;
            std::get< 1>(values_) = 0.0;
            std::get< 2>(values_) = 0.0;
        }
        GPSPosition(const double &_currentLatitude, const double &_currentLongitude, const double &_currentAltitude)
        {
            std::get< 0>(values_) = _currentLatitude;
            std::get< 1>(values_) = _currentLongitude;
            std::get< 2>(values_) = _currentAltitude;
        }
        /*
         * description: 
         * The current latitude coordinates of the vehicle
         */
        inline const double &getCurrentLatitude() const { return std::get< 0>(values_); }
        inline void setCurrentLatitude(const double &_value) { std::get< 0>(values_) = _value; }
        /*
         * description: 
         * The current longitude coordinates of the vehicle
         */
        inline const double &getCurrentLongitude() const { return std::get< 1>(values_); }
        inline void setCurrentLongitude(const double &_value) { std::get< 1>(values_) = _value; }
        /*
         * description: 
         * The current altitude coordinates of the vehicle
         */
        inline const double &getCurrentAltitude() const { return std::get< 2>(values_); }
        inline void setCurrentAltitude(const double &_value) { std::get< 2>(values_) = _value; }
        inline bool operator==(const GPSPosition& _other) const {
        return (getCurrentLatitude() == _other.getCurrentLatitude() && getCurrentLongitude() == _other.getCurrentLongitude() && getCurrentAltitude() == _other.getCurrentAltitude());
        }
        inline bool operator!=(const GPSPosition &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct StatusGPS : CommonAPI::Struct< GPSDate, GPSTime, GPSPosition> {
    
        StatusGPS()
        {
            std::get< 0>(values_) = GPSDate();
            std::get< 1>(values_) = GPSTime();
            std::get< 2>(values_) = GPSPosition();
        }
        StatusGPS(const GPSDate &_statusGPSDate, const GPSTime &_statusGPSTime, const GPSPosition &_statusfGPSPosition)
        {
            std::get< 0>(values_) = _statusGPSDate;
            std::get< 1>(values_) = _statusGPSTime;
            std::get< 2>(values_) = _statusfGPSPosition;
        }
        /*
         * description: 
         * GPS status date
         */
        inline const GPSDate &getStatusGPSDate() const { return std::get< 0>(values_); }
        inline void setStatusGPSDate(const GPSDate &_value) { std::get< 0>(values_) = _value; }
        /*
         * description: 
         * GPS status time
         */
        inline const GPSTime &getStatusGPSTime() const { return std::get< 1>(values_); }
        inline void setStatusGPSTime(const GPSTime &_value) { std::get< 1>(values_) = _value; }
        /*
         * description: 
         * GPS status position
         */
        inline const GPSPosition &getStatusfGPSPosition() const { return std::get< 2>(values_); }
        inline void setStatusfGPSPosition(const GPSPosition &_value) { std::get< 2>(values_) = _value; }
        inline bool operator==(const StatusGPS& _other) const {
        return (getStatusGPSDate() == _other.getStatusGPSDate() && getStatusGPSTime() == _other.getStatusGPSTime() && getStatusfGPSPosition() == _other.getStatusfGPSPosition());
        }
        inline bool operator!=(const StatusGPS &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct DoorsStatus : CommonAPI::Struct< bool, bool, bool, bool> {
    
        DoorsStatus()
        {
            std::get< 0>(values_) = false;
            std::get< 1>(values_) = false;
            std::get< 2>(values_) = false;
            std::get< 3>(values_) = false;
        }
        DoorsStatus(const bool &_frontLeft, const bool &_frontRight, const bool &_rearLeft, const bool &_rearRight)
        {
            std::get< 0>(values_) = _frontLeft;
            std::get< 1>(values_) = _frontRight;
            std::get< 2>(values_) = _rearLeft;
            std::get< 3>(values_) = _rearRight;
        }
        /*
         * description: 
         * The opening status of the front left door
         */
        inline const bool &getFrontLeft() const { return std::get< 0>(values_); }
        inline void setFrontLeft(const bool _value) { std::get< 0>(values_) = _value; }
        /*
         * description: 
         * The opening status of the front right door
         */
        inline const bool &getFrontRight() const { return std::get< 1>(values_); }
        inline void setFrontRight(const bool _value) { std::get< 1>(values_) = _value; }
        /*
         * description: 
         * The opening status of the rear left door
         */
        inline const bool &getRearLeft() const { return std::get< 2>(values_); }
        inline void setRearLeft(const bool _value) { std::get< 2>(values_) = _value; }
        /*
         * description: 
         * The opening status of the rear right door
         */
        inline const bool &getRearRight() const { return std::get< 3>(values_); }
        inline void setRearRight(const bool _value) { std::get< 3>(values_) = _value; }
        inline bool operator==(const DoorsStatus& _other) const {
        return (getFrontLeft() == _other.getFrontLeft() && getFrontRight() == _other.getFrontRight() && getRearLeft() == _other.getRearLeft() && getRearRight() == _other.getRearRight());
        }
        inline bool operator!=(const DoorsStatus &_other) const {
            return !((*this) == _other);
        }
    
    };
    
    struct DoorsID : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            /*
             * description: 
             * Front left door
             */
            FRONT_LEFT = 0,
            /*
             * description: 
             * Front right door
             */
            FRONT_RIGHT = 1,
            /*
             * description: 
             * Rear left door
             */
            REAR_LEFT = 2,
            /*
             * description: 
             * Rear right door
             */
            REAR_RIGHT = 3
        };
    
        DoorsID()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::FRONT_LEFT)) {}
        DoorsID(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::FRONT_LEFT):
                case static_cast< uint8_t>(Literal::FRONT_RIGHT):
                case static_cast< uint8_t>(Literal::REAR_LEFT):
                case static_cast< uint8_t>(Literal::REAR_RIGHT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const DoorsID &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const DoorsID &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const DoorsID &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const DoorsID &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const DoorsID &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const DoorsID &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint8_t>(Literal::FRONT_LEFT): return "FRONT_LEFT";
            case static_cast< uint8_t>(Literal::FRONT_RIGHT): return "FRONT_RIGHT";
            case static_cast< uint8_t>(Literal::REAR_LEFT): return "REAR_LEFT";
            case static_cast< uint8_t>(Literal::REAR_RIGHT): return "REAR_RIGHT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct DoorCommand : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            /*
             * description: 
             * Command for keeping the current door state
             */
            NOTHING = 0,
            /*
             * description: 
             * Command for opening the door
             */
            OPEN_DOOR = 1,
            /*
             * description: 
             * Command for closing the door
             */
            CLOSE_DOOR = 2
        };
    
        DoorCommand()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::NOTHING)) {}
        DoorCommand(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::NOTHING):
                case static_cast< uint8_t>(Literal::OPEN_DOOR):
                case static_cast< uint8_t>(Literal::CLOSE_DOOR):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const DoorCommand &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const DoorCommand &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const DoorCommand &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const DoorCommand &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const DoorCommand &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const DoorCommand &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint8_t>(Literal::NOTHING): return "NOTHING";
            case static_cast< uint8_t>(Literal::OPEN_DOOR): return "OPEN_DOOR";
            case static_cast< uint8_t>(Literal::CLOSE_DOOR): return "CLOSE_DOOR";
            default: return "UNDEFINED";
            }
        }
    };
    /*
     * description: 
     * All the doors opening state for the vehicle
     */
    struct CarDoorsCommand : CommonAPI::Struct< DoorCommand, DoorCommand, DoorCommand, DoorCommand> {
    
        CarDoorsCommand()
        {
            std::get< 0>(values_) = DoorCommand();
            std::get< 1>(values_) = DoorCommand();
            std::get< 2>(values_) = DoorCommand();
            std::get< 3>(values_) = DoorCommand();
        }
        CarDoorsCommand(const DoorCommand &_frontLeftDoor, const DoorCommand &_frontRightDoor, const DoorCommand &_rearLeftDoor, const DoorCommand &_rearRightDoor)
        {
            std::get< 0>(values_) = _frontLeftDoor;
            std::get< 1>(values_) = _frontRightDoor;
            std::get< 2>(values_) = _rearLeftDoor;
            std::get< 3>(values_) = _rearRightDoor;
        }
        /*
         * description: 
         * Front left door command
         */
        inline const DoorCommand &getFrontLeftDoor() const { return std::get< 0>(values_); }
        inline void setFrontLeftDoor(const DoorCommand &_value) { std::get< 0>(values_) = _value; }
        /*
         * description: 
         * Front right door command
         */
        inline const DoorCommand &getFrontRightDoor() const { return std::get< 1>(values_); }
        inline void setFrontRightDoor(const DoorCommand &_value) { std::get< 1>(values_) = _value; }
        /*
         * description: 
         * Rear left door command
         */
        inline const DoorCommand &getRearLeftDoor() const { return std::get< 2>(values_); }
        inline void setRearLeftDoor(const DoorCommand &_value) { std::get< 2>(values_) = _value; }
        /*
         * description: 
         * Rear right door command
         */
        inline const DoorCommand &getRearRightDoor() const { return std::get< 3>(values_); }
        inline void setRearRightDoor(const DoorCommand &_value) { std::get< 3>(values_) = _value; }
        inline bool operator==(const CarDoorsCommand& _other) const {
        return (getFrontLeftDoor() == _other.getFrontLeftDoor() && getFrontRightDoor() == _other.getFrontRightDoor() && getRearLeftDoor() == _other.getRearLeftDoor() && getRearRightDoor() == _other.getRearRightDoor());
        }
        inline bool operator!=(const CarDoorsCommand &_other) const {
            return !((*this) == _other);
        }
    
    };


static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "org.genivi.vehicle.playgroundtypes.PlaygroundTypes";
    return typeCollectionName;
}


}; // struct PlaygroundTypes

} // namespace playgroundtypes
} // namespace vehicle
} // namespace genivi
} // namespace org

namespace CommonAPI {
}


namespace std {
    //Hash for Gear
    template<>
    struct hash< ::org::genivi::vehicle::playgroundtypes::PlaygroundTypes::Gear> {
        inline size_t operator()(const ::org::genivi::vehicle::playgroundtypes::PlaygroundTypes::Gear& gear) const {
            return static_cast< uint8_t>(gear);
        }
    };
    //Hash for DriveType
    template<>
    struct hash< ::org::genivi::vehicle::playgroundtypes::PlaygroundTypes::DriveType> {
        inline size_t operator()(const ::org::genivi::vehicle::playgroundtypes::PlaygroundTypes::DriveType& driveType) const {
            return static_cast< uint8_t>(driveType);
        }
    };
    //Hash for DoorsID
    template<>
    struct hash< ::org::genivi::vehicle::playgroundtypes::PlaygroundTypes::DoorsID> {
        inline size_t operator()(const ::org::genivi::vehicle::playgroundtypes::PlaygroundTypes::DoorsID& doorsID) const {
            return static_cast< uint8_t>(doorsID);
        }
    };
    //Hash for DoorCommand
    template<>
    struct hash< ::org::genivi::vehicle::playgroundtypes::PlaygroundTypes::DoorCommand> {
        inline size_t operator()(const ::org::genivi::vehicle::playgroundtypes::PlaygroundTypes::DoorCommand& doorCommand) const {
            return static_cast< uint8_t>(doorCommand);
        }
    };
}



#endif // ORG_GENIVI_VEHICLE_PLAYGROUNDTYPES_Playground_Types_HPP_
