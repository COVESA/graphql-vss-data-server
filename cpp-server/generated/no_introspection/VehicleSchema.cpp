// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// WARNING! Do not edit this file manually, your changes will be overwritten.

#include "VehicleSchema.h"

#include "graphqlservice/introspection/Introspection.h"

#include <algorithm>
#include <array>
#include <functional>
#include <sstream>
#include <stdexcept>
#include <string_view>
#include <tuple>
#include <vector>

using namespace std::literals;

namespace graphql {
namespace service {

static const std::array<std::string_view, 2> s_namesHasPermissionsDirectivePolicy = {
	"RESOLVER"sv,
	"THROW"sv
};

template <>
vehicle::HasPermissionsDirectivePolicy ModifiedArgument<vehicle::HasPermissionsDirectivePolicy>::convert(const response::Value& value)
{
	if (!value.maybe_enum())
	{
		throw service::schema_exception { { "not a valid HasPermissionsDirectivePolicy value" } };
	}

	const auto itr = std::find(s_namesHasPermissionsDirectivePolicy.cbegin(), s_namesHasPermissionsDirectivePolicy.cend(), value.get<response::StringType>());

	if (itr == s_namesHasPermissionsDirectivePolicy.cend())
	{
		throw service::schema_exception { { "not a valid HasPermissionsDirectivePolicy value" } };
	}

	return static_cast<vehicle::HasPermissionsDirectivePolicy>(itr - s_namesHasPermissionsDirectivePolicy.cbegin());
}

template <>
std::future<service::ResolverResult> ModifiedResult<vehicle::HasPermissionsDirectivePolicy>::convert(service::FieldResult<vehicle::HasPermissionsDirectivePolicy>&& result, ResolverParams&& params)
{
	return resolve(std::move(result), std::move(params),
		[](vehicle::HasPermissionsDirectivePolicy value, const ResolverParams&)
		{
			response::Value result(response::Type::EnumValue);

			result.set<response::StringType>(response::StringType { s_namesHasPermissionsDirectivePolicy[static_cast<size_t>(value)] });

			return result;
		});
}

static const std::array<std::string_view, 3> s_namesSubscriptionDeliveryInterval = {
	"DELIVERY_INTERVAL_5_SECONDS"sv,
	"DELIVERY_INTERVAL_1_SECOND"sv,
	"REALTIME"sv
};

template <>
vehicle::SubscriptionDeliveryInterval ModifiedArgument<vehicle::SubscriptionDeliveryInterval>::convert(const response::Value& value)
{
	if (!value.maybe_enum())
	{
		throw service::schema_exception { { "not a valid SubscriptionDeliveryInterval value" } };
	}

	const auto itr = std::find(s_namesSubscriptionDeliveryInterval.cbegin(), s_namesSubscriptionDeliveryInterval.cend(), value.get<response::StringType>());

	if (itr == s_namesSubscriptionDeliveryInterval.cend())
	{
		throw service::schema_exception { { "not a valid SubscriptionDeliveryInterval value" } };
	}

	return static_cast<vehicle::SubscriptionDeliveryInterval>(itr - s_namesSubscriptionDeliveryInterval.cbegin());
}

template <>
std::future<service::ResolverResult> ModifiedResult<vehicle::SubscriptionDeliveryInterval>::convert(service::FieldResult<vehicle::SubscriptionDeliveryInterval>&& result, ResolverParams&& params)
{
	return resolve(std::move(result), std::move(params),
		[](vehicle::SubscriptionDeliveryInterval value, const ResolverParams&)
		{
			response::Value result(response::Type::EnumValue);

			result.set<response::StringType>(response::StringType { s_namesSubscriptionDeliveryInterval[static_cast<size_t>(value)] });

			return result;
		});
}

template <>
vehicle::Vehicle_Cabin_Door_Row1_Left_Input ModifiedArgument<vehicle::Vehicle_Cabin_Door_Row1_Left_Input>::convert(const response::Value& value)
{
	auto valueIsOpen = service::ModifiedArgument<response::BooleanType>::require<service::TypeModifier::Nullable>("isOpen", value);

	return {
		std::move(valueIsOpen)
	};
}

template <>
vehicle::Vehicle_Cabin_Door_Row1_Right_Input ModifiedArgument<vehicle::Vehicle_Cabin_Door_Row1_Right_Input>::convert(const response::Value& value)
{
	auto valueIsOpen = service::ModifiedArgument<response::BooleanType>::require<service::TypeModifier::Nullable>("isOpen", value);

	return {
		std::move(valueIsOpen)
	};
}

template <>
vehicle::Vehicle_Cabin_Door_Row2_Left_Input ModifiedArgument<vehicle::Vehicle_Cabin_Door_Row2_Left_Input>::convert(const response::Value& value)
{
	auto valueIsOpen = service::ModifiedArgument<response::BooleanType>::require<service::TypeModifier::Nullable>("isOpen", value);

	return {
		std::move(valueIsOpen)
	};
}

template <>
vehicle::Vehicle_Cabin_Door_Row2_Right_Input ModifiedArgument<vehicle::Vehicle_Cabin_Door_Row2_Right_Input>::convert(const response::Value& value)
{
	auto valueIsOpen = service::ModifiedArgument<response::BooleanType>::require<service::TypeModifier::Nullable>("isOpen", value);

	return {
		std::move(valueIsOpen)
	};
}

template <>
vehicle::Vehicle_Cabin_Seat_Row1_Pos1_Input ModifiedArgument<vehicle::Vehicle_Cabin_Seat_Row1_Pos1_Input>::convert(const response::Value& value)
{
	auto valueHeating = service::ModifiedArgument<response::Value>::require<service::TypeModifier::Nullable>("heating", value);

	return {
		std::move(valueHeating)
	};
}

template <>
vehicle::Vehicle_Cabin_Seat_Row1_Pos2_Input ModifiedArgument<vehicle::Vehicle_Cabin_Seat_Row1_Pos2_Input>::convert(const response::Value& value)
{
	auto valueHeating = service::ModifiedArgument<response::Value>::require<service::TypeModifier::Nullable>("heating", value);

	return {
		std::move(valueHeating)
	};
}

template <>
vehicle::Vehicle_Cabin_Seat_Row2_Pos1_Input ModifiedArgument<vehicle::Vehicle_Cabin_Seat_Row2_Pos1_Input>::convert(const response::Value& value)
{
	auto valueHeating = service::ModifiedArgument<response::Value>::require<service::TypeModifier::Nullable>("heating", value);

	return {
		std::move(valueHeating)
	};
}

template <>
vehicle::Vehicle_Cabin_Seat_Row2_Pos2_Input ModifiedArgument<vehicle::Vehicle_Cabin_Seat_Row2_Pos2_Input>::convert(const response::Value& value)
{
	auto valueHeating = service::ModifiedArgument<response::Value>::require<service::TypeModifier::Nullable>("heating", value);

	return {
		std::move(valueHeating)
	};
}

} // namespace service

namespace vehicle {
namespace object {

Query::Query()
	: service::Object({
		"Query"
	}, {
		{ R"gql(vehicle)gql"sv, [this](service::ResolverParams&& params) { return resolveVehicle(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } }
	})
{
}

service::FieldResult<std::shared_ptr<Vehicle>> Query::getVehicle(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Query::getVehicle is not implemented)ex");
}

std::future<service::ResolverResult> Query::resolveVehicle(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getVehicle(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Query::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Query)gql" }, std::move(params));
}

Subscription::Subscription()
	: service::Object({
		"Subscription"
	}, {
		{ R"gql(vehicle)gql"sv, [this](service::ResolverParams&& params) { return resolveVehicle(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } }
	})
{
}

service::FieldResult<std::shared_ptr<Vehicle>> Subscription::getVehicle(service::FieldParams&&, SubscriptionDeliveryInterval&&) const
{
	throw std::runtime_error(R"ex(Subscription::getVehicle is not implemented)ex");
}

std::future<service::ResolverResult> Subscription::resolveVehicle(service::ResolverParams&& params)
{
	const auto defaultArguments = []()
	{
		response::Value values(response::Type::Map);
		response::Value entry;

		entry = response::Value(response::Type::EnumValue);
		entry.set<response::StringType>(R"gql(DELIVERY_INTERVAL_5_SECONDS)gql");
		values.emplace_back("deliveryInterval", std::move(entry));

		return values;
	}();

	auto pairDeliveryInterval = service::ModifiedArgument<vehicle::SubscriptionDeliveryInterval>::find("deliveryInterval", params.arguments);
	auto argDeliveryInterval = (pairDeliveryInterval.second
		? std::move(pairDeliveryInterval.first)
		: service::ModifiedArgument<vehicle::SubscriptionDeliveryInterval>::require("deliveryInterval", defaultArguments));
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getVehicle(service::FieldParams(std::move(params), std::move(directives)), std::move(argDeliveryInterval));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Subscription::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Subscription)gql" }, std::move(params));
}

Mutation::Mutation()
	: service::Object({
		"Mutation"
	}, {
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } },
		{ R"gql(setVehicleCabinDoorRow1Left)gql"sv, [this](service::ResolverParams&& params) { return resolveSetVehicleCabinDoorRow1Left(std::move(params)); } },
		{ R"gql(setVehicleCabinDoorRow2Left)gql"sv, [this](service::ResolverParams&& params) { return resolveSetVehicleCabinDoorRow2Left(std::move(params)); } },
		{ R"gql(setVehicleCabinSeatRow1Pos1)gql"sv, [this](service::ResolverParams&& params) { return resolveSetVehicleCabinSeatRow1Pos1(std::move(params)); } },
		{ R"gql(setVehicleCabinSeatRow1Pos2)gql"sv, [this](service::ResolverParams&& params) { return resolveSetVehicleCabinSeatRow1Pos2(std::move(params)); } },
		{ R"gql(setVehicleCabinSeatRow2Pos1)gql"sv, [this](service::ResolverParams&& params) { return resolveSetVehicleCabinSeatRow2Pos1(std::move(params)); } },
		{ R"gql(setVehicleCabinSeatRow2Pos2)gql"sv, [this](service::ResolverParams&& params) { return resolveSetVehicleCabinSeatRow2Pos2(std::move(params)); } },
		{ R"gql(setVehicleCabinDoorRow1Right)gql"sv, [this](service::ResolverParams&& params) { return resolveSetVehicleCabinDoorRow1Right(std::move(params)); } },
		{ R"gql(setVehicleCabinDoorRow2Right)gql"sv, [this](service::ResolverParams&& params) { return resolveSetVehicleCabinDoorRow2Right(std::move(params)); } }
	})
{
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Door_Row1_Left>> Mutation::applySetVehicleCabinDoorRow1Left(service::FieldParams&&, Vehicle_Cabin_Door_Row1_Left_Input&&) const
{
	throw std::runtime_error(R"ex(Mutation::applySetVehicleCabinDoorRow1Left is not implemented)ex");
}

std::future<service::ResolverResult> Mutation::resolveSetVehicleCabinDoorRow1Left(service::ResolverParams&& params)
{
	auto argInput = service::ModifiedArgument<vehicle::Vehicle_Cabin_Door_Row1_Left_Input>::require("input", params.arguments);
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = applySetVehicleCabinDoorRow1Left(service::FieldParams(std::move(params), std::move(directives)), std::move(argInput));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Door_Row1_Left>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Door_Row1_Right>> Mutation::applySetVehicleCabinDoorRow1Right(service::FieldParams&&, Vehicle_Cabin_Door_Row1_Right_Input&&) const
{
	throw std::runtime_error(R"ex(Mutation::applySetVehicleCabinDoorRow1Right is not implemented)ex");
}

std::future<service::ResolverResult> Mutation::resolveSetVehicleCabinDoorRow1Right(service::ResolverParams&& params)
{
	auto argInput = service::ModifiedArgument<vehicle::Vehicle_Cabin_Door_Row1_Right_Input>::require("input", params.arguments);
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = applySetVehicleCabinDoorRow1Right(service::FieldParams(std::move(params), std::move(directives)), std::move(argInput));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Door_Row1_Right>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Door_Row2_Left>> Mutation::applySetVehicleCabinDoorRow2Left(service::FieldParams&&, Vehicle_Cabin_Door_Row2_Left_Input&&) const
{
	throw std::runtime_error(R"ex(Mutation::applySetVehicleCabinDoorRow2Left is not implemented)ex");
}

std::future<service::ResolverResult> Mutation::resolveSetVehicleCabinDoorRow2Left(service::ResolverParams&& params)
{
	auto argInput = service::ModifiedArgument<vehicle::Vehicle_Cabin_Door_Row2_Left_Input>::require("input", params.arguments);
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = applySetVehicleCabinDoorRow2Left(service::FieldParams(std::move(params), std::move(directives)), std::move(argInput));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Door_Row2_Left>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Door_Row2_Right>> Mutation::applySetVehicleCabinDoorRow2Right(service::FieldParams&&, Vehicle_Cabin_Door_Row2_Right_Input&&) const
{
	throw std::runtime_error(R"ex(Mutation::applySetVehicleCabinDoorRow2Right is not implemented)ex");
}

std::future<service::ResolverResult> Mutation::resolveSetVehicleCabinDoorRow2Right(service::ResolverParams&& params)
{
	auto argInput = service::ModifiedArgument<vehicle::Vehicle_Cabin_Door_Row2_Right_Input>::require("input", params.arguments);
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = applySetVehicleCabinDoorRow2Right(service::FieldParams(std::move(params), std::move(directives)), std::move(argInput));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Door_Row2_Right>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Seat_Row1_Pos1>> Mutation::applySetVehicleCabinSeatRow1Pos1(service::FieldParams&&, Vehicle_Cabin_Seat_Row1_Pos1_Input&&) const
{
	throw std::runtime_error(R"ex(Mutation::applySetVehicleCabinSeatRow1Pos1 is not implemented)ex");
}

std::future<service::ResolverResult> Mutation::resolveSetVehicleCabinSeatRow1Pos1(service::ResolverParams&& params)
{
	auto argInput = service::ModifiedArgument<vehicle::Vehicle_Cabin_Seat_Row1_Pos1_Input>::require("input", params.arguments);
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = applySetVehicleCabinSeatRow1Pos1(service::FieldParams(std::move(params), std::move(directives)), std::move(argInput));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Seat_Row1_Pos1>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Seat_Row1_Pos2>> Mutation::applySetVehicleCabinSeatRow1Pos2(service::FieldParams&&, Vehicle_Cabin_Seat_Row1_Pos2_Input&&) const
{
	throw std::runtime_error(R"ex(Mutation::applySetVehicleCabinSeatRow1Pos2 is not implemented)ex");
}

std::future<service::ResolverResult> Mutation::resolveSetVehicleCabinSeatRow1Pos2(service::ResolverParams&& params)
{
	auto argInput = service::ModifiedArgument<vehicle::Vehicle_Cabin_Seat_Row1_Pos2_Input>::require("input", params.arguments);
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = applySetVehicleCabinSeatRow1Pos2(service::FieldParams(std::move(params), std::move(directives)), std::move(argInput));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Seat_Row1_Pos2>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Seat_Row2_Pos1>> Mutation::applySetVehicleCabinSeatRow2Pos1(service::FieldParams&&, Vehicle_Cabin_Seat_Row2_Pos1_Input&&) const
{
	throw std::runtime_error(R"ex(Mutation::applySetVehicleCabinSeatRow2Pos1 is not implemented)ex");
}

std::future<service::ResolverResult> Mutation::resolveSetVehicleCabinSeatRow2Pos1(service::ResolverParams&& params)
{
	auto argInput = service::ModifiedArgument<vehicle::Vehicle_Cabin_Seat_Row2_Pos1_Input>::require("input", params.arguments);
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = applySetVehicleCabinSeatRow2Pos1(service::FieldParams(std::move(params), std::move(directives)), std::move(argInput));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Seat_Row2_Pos1>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Seat_Row2_Pos2>> Mutation::applySetVehicleCabinSeatRow2Pos2(service::FieldParams&&, Vehicle_Cabin_Seat_Row2_Pos2_Input&&) const
{
	throw std::runtime_error(R"ex(Mutation::applySetVehicleCabinSeatRow2Pos2 is not implemented)ex");
}

std::future<service::ResolverResult> Mutation::resolveSetVehicleCabinSeatRow2Pos2(service::ResolverParams&& params)
{
	auto argInput = service::ModifiedArgument<vehicle::Vehicle_Cabin_Seat_Row2_Pos2_Input>::require("input", params.arguments);
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = applySetVehicleCabinSeatRow2Pos2(service::FieldParams(std::move(params), std::move(directives)), std::move(argInput));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Seat_Row2_Pos2>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Mutation::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Mutation)gql" }, std::move(params));
}

Vehicle::Vehicle()
	: service::Object({
		"Vehicle"
	}, {
		{ R"gql(cabin)gql"sv, [this](service::ResolverParams&& params) { return resolveCabin(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } },
		{ R"gql(powertrain)gql"sv, [this](service::ResolverParams&& params) { return resolvePowertrain(std::move(params)); } },
		{ R"gql(currentLocation)gql"sv, [this](service::ResolverParams&& params) { return resolveCurrentLocation(std::move(params)); } }
	})
{
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin>> Vehicle::getCabin(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle::getCabin is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle::resolveCabin(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getCabin(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::shared_ptr<Vehicle_CurrentLocation>> Vehicle::getCurrentLocation(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle::getCurrentLocation is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle::resolveCurrentLocation(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getCurrentLocation(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_CurrentLocation>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::shared_ptr<Vehicle_Powertrain>> Vehicle::getPowertrain(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle::getPowertrain is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle::resolvePowertrain(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getPowertrain(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Powertrain>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle)gql" }, std::move(params));
}

Vehicle_Cabin::Vehicle_Cabin()
	: service::Object({
		"Vehicle_Cabin"
	}, {
		{ R"gql(door)gql"sv, [this](service::ResolverParams&& params) { return resolveDoor(std::move(params)); } },
		{ R"gql(seat)gql"sv, [this](service::ResolverParams&& params) { return resolveSeat(std::move(params)); } },
		{ R"gql(doorCount)gql"sv, [this](service::ResolverParams&& params) { return resolveDoorCount(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } }
	})
{
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Door>> Vehicle_Cabin::getDoor(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin::getDoor is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin::resolveDoor(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getDoor(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Door>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::optional<response::Value>> Vehicle_Cabin::getDoorCount(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin::getDoorCount is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin::resolveDoorCount(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getDoorCount(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<response::Value>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Seat>> Vehicle_Cabin::getSeat(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin::getSeat is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin::resolveSeat(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getSeat(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Seat>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_Cabin::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_Cabin)gql" }, std::move(params));
}

Vehicle_CurrentLocation::Vehicle_CurrentLocation()
	: service::Object({
		"Vehicle_CurrentLocation"
	}, {
		{ R"gql(altitude)gql"sv, [this](service::ResolverParams&& params) { return resolveAltitude(std::move(params)); } },
		{ R"gql(latitude)gql"sv, [this](service::ResolverParams&& params) { return resolveLatitude(std::move(params)); } },
		{ R"gql(longitude)gql"sv, [this](service::ResolverParams&& params) { return resolveLongitude(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } }
	})
{
}

service::FieldResult<std::optional<response::FloatType>> Vehicle_CurrentLocation::getAltitude(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_CurrentLocation::getAltitude is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_CurrentLocation::resolveAltitude(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getAltitude(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<response::FloatType>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::optional<response::FloatType>> Vehicle_CurrentLocation::getLatitude(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_CurrentLocation::getLatitude is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_CurrentLocation::resolveLatitude(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getLatitude(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<response::FloatType>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::optional<response::FloatType>> Vehicle_CurrentLocation::getLongitude(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_CurrentLocation::getLongitude is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_CurrentLocation::resolveLongitude(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getLongitude(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<response::FloatType>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_CurrentLocation::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_CurrentLocation)gql" }, std::move(params));
}

Vehicle_Powertrain::Vehicle_Powertrain()
	: service::Object({
		"Vehicle_Powertrain"
	}, {
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } },
		{ R"gql(fuelSystem)gql"sv, [this](service::ResolverParams&& params) { return resolveFuelSystem(std::move(params)); } },
		{ R"gql(transmission)gql"sv, [this](service::ResolverParams&& params) { return resolveTransmission(std::move(params)); } },
		{ R"gql(combustionEngine)gql"sv, [this](service::ResolverParams&& params) { return resolveCombustionEngine(std::move(params)); } }
	})
{
}

service::FieldResult<std::shared_ptr<Vehicle_Powertrain_CombustionEngine>> Vehicle_Powertrain::getCombustionEngine(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Powertrain::getCombustionEngine is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Powertrain::resolveCombustionEngine(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getCombustionEngine(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Powertrain_CombustionEngine>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::shared_ptr<Vehicle_Powertrain_FuelSystem>> Vehicle_Powertrain::getFuelSystem(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Powertrain::getFuelSystem is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Powertrain::resolveFuelSystem(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getFuelSystem(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Powertrain_FuelSystem>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::shared_ptr<Vehicle_Powertrain_Transmission>> Vehicle_Powertrain::getTransmission(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Powertrain::getTransmission is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Powertrain::resolveTransmission(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getTransmission(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Powertrain_Transmission>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_Powertrain::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_Powertrain)gql" }, std::move(params));
}

Vehicle_Cabin_Door::Vehicle_Cabin_Door()
	: service::Object({
		"Vehicle_Cabin_Door"
	}, {
		{ R"gql(row1)gql"sv, [this](service::ResolverParams&& params) { return resolveRow1(std::move(params)); } },
		{ R"gql(row2)gql"sv, [this](service::ResolverParams&& params) { return resolveRow2(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } }
	})
{
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Door_Row1>> Vehicle_Cabin_Door::getRow1(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin_Door::getRow1 is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin_Door::resolveRow1(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getRow1(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Door_Row1>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Door_Row2>> Vehicle_Cabin_Door::getRow2(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin_Door::getRow2 is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin_Door::resolveRow2(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getRow2(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Door_Row2>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_Cabin_Door::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_Cabin_Door)gql" }, std::move(params));
}

Vehicle_Cabin_Seat::Vehicle_Cabin_Seat()
	: service::Object({
		"Vehicle_Cabin_Seat"
	}, {
		{ R"gql(row1)gql"sv, [this](service::ResolverParams&& params) { return resolveRow1(std::move(params)); } },
		{ R"gql(row2)gql"sv, [this](service::ResolverParams&& params) { return resolveRow2(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } }
	})
{
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Seat_Row1>> Vehicle_Cabin_Seat::getRow1(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin_Seat::getRow1 is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin_Seat::resolveRow1(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getRow1(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Seat_Row1>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Seat_Row2>> Vehicle_Cabin_Seat::getRow2(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin_Seat::getRow2 is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin_Seat::resolveRow2(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getRow2(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Seat_Row2>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_Cabin_Seat::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_Cabin_Seat)gql" }, std::move(params));
}

Vehicle_Powertrain_CombustionEngine::Vehicle_Powertrain_CombustionEngine()
	: service::Object({
		"Vehicle_Powertrain_CombustionEngine"
	}, {
		{ R"gql(engine)gql"sv, [this](service::ResolverParams&& params) { return resolveEngine(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } }
	})
{
}

service::FieldResult<std::shared_ptr<Vehicle_Powertrain_CombustionEngine_Engine>> Vehicle_Powertrain_CombustionEngine::getEngine(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Powertrain_CombustionEngine::getEngine is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Powertrain_CombustionEngine::resolveEngine(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getEngine(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Powertrain_CombustionEngine_Engine>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_Powertrain_CombustionEngine::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_Powertrain_CombustionEngine)gql" }, std::move(params));
}

Vehicle_Powertrain_FuelSystem::Vehicle_Powertrain_FuelSystem()
	: service::Object({
		"Vehicle_Powertrain_FuelSystem"
	}, {
		{ R"gql(level)gql"sv, [this](service::ResolverParams&& params) { return resolveLevel(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } },
		{ R"gql(tankCapacity)gql"sv, [this](service::ResolverParams&& params) { return resolveTankCapacity(std::move(params)); } },
		{ R"gql(instantConsumption)gql"sv, [this](service::ResolverParams&& params) { return resolveInstantConsumption(std::move(params)); } }
	})
{
}

service::FieldResult<std::optional<response::FloatType>> Vehicle_Powertrain_FuelSystem::getInstantConsumption(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Powertrain_FuelSystem::getInstantConsumption is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Powertrain_FuelSystem::resolveInstantConsumption(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getInstantConsumption(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<response::FloatType>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::optional<response::Value>> Vehicle_Powertrain_FuelSystem::getLevel(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Powertrain_FuelSystem::getLevel is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Powertrain_FuelSystem::resolveLevel(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getLevel(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<response::Value>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::optional<response::FloatType>> Vehicle_Powertrain_FuelSystem::getTankCapacity(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Powertrain_FuelSystem::getTankCapacity is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Powertrain_FuelSystem::resolveTankCapacity(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getTankCapacity(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<response::FloatType>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_Powertrain_FuelSystem::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_Powertrain_FuelSystem)gql" }, std::move(params));
}

Vehicle_Powertrain_Transmission::Vehicle_Powertrain_Transmission()
	: service::Object({
		"Vehicle_Powertrain_Transmission"
	}, {
		{ R"gql(driveType)gql"sv, [this](service::ResolverParams&& params) { return resolveDriveType(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } },
		{ R"gql(currentGear)gql"sv, [this](service::ResolverParams&& params) { return resolveCurrentGear(std::move(params)); } }
	})
{
}

service::FieldResult<std::optional<response::Value>> Vehicle_Powertrain_Transmission::getCurrentGear(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Powertrain_Transmission::getCurrentGear is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Powertrain_Transmission::resolveCurrentGear(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getCurrentGear(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<response::Value>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::optional<response::StringType>> Vehicle_Powertrain_Transmission::getDriveType(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Powertrain_Transmission::getDriveType is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Powertrain_Transmission::resolveDriveType(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getDriveType(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<response::StringType>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_Powertrain_Transmission::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_Powertrain_Transmission)gql" }, std::move(params));
}

Vehicle_Cabin_Door_Row1::Vehicle_Cabin_Door_Row1()
	: service::Object({
		"Vehicle_Cabin_Door_Row1"
	}, {
		{ R"gql(left)gql"sv, [this](service::ResolverParams&& params) { return resolveLeft(std::move(params)); } },
		{ R"gql(right)gql"sv, [this](service::ResolverParams&& params) { return resolveRight(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } }
	})
{
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Door_Row1_Left>> Vehicle_Cabin_Door_Row1::getLeft(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin_Door_Row1::getLeft is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin_Door_Row1::resolveLeft(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getLeft(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Door_Row1_Left>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Door_Row1_Right>> Vehicle_Cabin_Door_Row1::getRight(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin_Door_Row1::getRight is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin_Door_Row1::resolveRight(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getRight(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Door_Row1_Right>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_Cabin_Door_Row1::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_Cabin_Door_Row1)gql" }, std::move(params));
}

Vehicle_Cabin_Door_Row2::Vehicle_Cabin_Door_Row2()
	: service::Object({
		"Vehicle_Cabin_Door_Row2"
	}, {
		{ R"gql(left)gql"sv, [this](service::ResolverParams&& params) { return resolveLeft(std::move(params)); } },
		{ R"gql(right)gql"sv, [this](service::ResolverParams&& params) { return resolveRight(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } }
	})
{
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Door_Row2_Left>> Vehicle_Cabin_Door_Row2::getLeft(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin_Door_Row2::getLeft is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin_Door_Row2::resolveLeft(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getLeft(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Door_Row2_Left>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Door_Row2_Right>> Vehicle_Cabin_Door_Row2::getRight(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin_Door_Row2::getRight is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin_Door_Row2::resolveRight(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getRight(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Door_Row2_Right>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_Cabin_Door_Row2::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_Cabin_Door_Row2)gql" }, std::move(params));
}

Vehicle_Cabin_Seat_Row1::Vehicle_Cabin_Seat_Row1()
	: service::Object({
		"Vehicle_Cabin_Seat_Row1"
	}, {
		{ R"gql(pos1)gql"sv, [this](service::ResolverParams&& params) { return resolvePos1(std::move(params)); } },
		{ R"gql(pos2)gql"sv, [this](service::ResolverParams&& params) { return resolvePos2(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } }
	})
{
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Seat_Row1_Pos1>> Vehicle_Cabin_Seat_Row1::getPos1(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin_Seat_Row1::getPos1 is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin_Seat_Row1::resolvePos1(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getPos1(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Seat_Row1_Pos1>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Seat_Row1_Pos2>> Vehicle_Cabin_Seat_Row1::getPos2(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin_Seat_Row1::getPos2 is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin_Seat_Row1::resolvePos2(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getPos2(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Seat_Row1_Pos2>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_Cabin_Seat_Row1::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_Cabin_Seat_Row1)gql" }, std::move(params));
}

Vehicle_Cabin_Seat_Row2::Vehicle_Cabin_Seat_Row2()
	: service::Object({
		"Vehicle_Cabin_Seat_Row2"
	}, {
		{ R"gql(pos1)gql"sv, [this](service::ResolverParams&& params) { return resolvePos1(std::move(params)); } },
		{ R"gql(pos2)gql"sv, [this](service::ResolverParams&& params) { return resolvePos2(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } }
	})
{
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Seat_Row2_Pos1>> Vehicle_Cabin_Seat_Row2::getPos1(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin_Seat_Row2::getPos1 is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin_Seat_Row2::resolvePos1(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getPos1(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Seat_Row2_Pos1>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

service::FieldResult<std::shared_ptr<Vehicle_Cabin_Seat_Row2_Pos2>> Vehicle_Cabin_Seat_Row2::getPos2(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin_Seat_Row2::getPos2 is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin_Seat_Row2::resolvePos2(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getPos2(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<Vehicle_Cabin_Seat_Row2_Pos2>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_Cabin_Seat_Row2::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_Cabin_Seat_Row2)gql" }, std::move(params));
}

Vehicle_Powertrain_CombustionEngine_Engine::Vehicle_Powertrain_CombustionEngine_Engine()
	: service::Object({
		"Vehicle_Powertrain_CombustionEngine_Engine"
	}, {
		{ R"gql(speed)gql"sv, [this](service::ResolverParams&& params) { return resolveSpeed(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } }
	})
{
}

service::FieldResult<std::optional<response::Value>> Vehicle_Powertrain_CombustionEngine_Engine::getSpeed(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Powertrain_CombustionEngine_Engine::getSpeed is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Powertrain_CombustionEngine_Engine::resolveSpeed(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getSpeed(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<response::Value>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_Powertrain_CombustionEngine_Engine::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_Powertrain_CombustionEngine_Engine)gql" }, std::move(params));
}

Vehicle_Cabin_Door_Row1_Left::Vehicle_Cabin_Door_Row1_Left()
	: service::Object({
		"Vehicle_Cabin_Door_Row1_Left"
	}, {
		{ R"gql(isOpen)gql"sv, [this](service::ResolverParams&& params) { return resolveIsOpen(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } }
	})
{
}

service::FieldResult<std::optional<response::BooleanType>> Vehicle_Cabin_Door_Row1_Left::getIsOpen(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin_Door_Row1_Left::getIsOpen is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin_Door_Row1_Left::resolveIsOpen(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getIsOpen(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<response::BooleanType>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_Cabin_Door_Row1_Left::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_Cabin_Door_Row1_Left)gql" }, std::move(params));
}

Vehicle_Cabin_Door_Row1_Right::Vehicle_Cabin_Door_Row1_Right()
	: service::Object({
		"Vehicle_Cabin_Door_Row1_Right"
	}, {
		{ R"gql(isOpen)gql"sv, [this](service::ResolverParams&& params) { return resolveIsOpen(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } }
	})
{
}

service::FieldResult<std::optional<response::BooleanType>> Vehicle_Cabin_Door_Row1_Right::getIsOpen(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin_Door_Row1_Right::getIsOpen is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin_Door_Row1_Right::resolveIsOpen(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getIsOpen(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<response::BooleanType>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_Cabin_Door_Row1_Right::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_Cabin_Door_Row1_Right)gql" }, std::move(params));
}

Vehicle_Cabin_Door_Row2_Left::Vehicle_Cabin_Door_Row2_Left()
	: service::Object({
		"Vehicle_Cabin_Door_Row2_Left"
	}, {
		{ R"gql(isOpen)gql"sv, [this](service::ResolverParams&& params) { return resolveIsOpen(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } }
	})
{
}

service::FieldResult<std::optional<response::BooleanType>> Vehicle_Cabin_Door_Row2_Left::getIsOpen(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin_Door_Row2_Left::getIsOpen is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin_Door_Row2_Left::resolveIsOpen(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getIsOpen(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<response::BooleanType>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_Cabin_Door_Row2_Left::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_Cabin_Door_Row2_Left)gql" }, std::move(params));
}

Vehicle_Cabin_Door_Row2_Right::Vehicle_Cabin_Door_Row2_Right()
	: service::Object({
		"Vehicle_Cabin_Door_Row2_Right"
	}, {
		{ R"gql(isOpen)gql"sv, [this](service::ResolverParams&& params) { return resolveIsOpen(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } }
	})
{
}

service::FieldResult<std::optional<response::BooleanType>> Vehicle_Cabin_Door_Row2_Right::getIsOpen(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin_Door_Row2_Right::getIsOpen is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin_Door_Row2_Right::resolveIsOpen(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getIsOpen(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<response::BooleanType>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_Cabin_Door_Row2_Right::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_Cabin_Door_Row2_Right)gql" }, std::move(params));
}

Vehicle_Cabin_Seat_Row1_Pos1::Vehicle_Cabin_Seat_Row1_Pos1()
	: service::Object({
		"Vehicle_Cabin_Seat_Row1_Pos1"
	}, {
		{ R"gql(heating)gql"sv, [this](service::ResolverParams&& params) { return resolveHeating(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } }
	})
{
}

service::FieldResult<std::optional<response::Value>> Vehicle_Cabin_Seat_Row1_Pos1::getHeating(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin_Seat_Row1_Pos1::getHeating is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin_Seat_Row1_Pos1::resolveHeating(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getHeating(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<response::Value>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_Cabin_Seat_Row1_Pos1::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_Cabin_Seat_Row1_Pos1)gql" }, std::move(params));
}

Vehicle_Cabin_Seat_Row1_Pos2::Vehicle_Cabin_Seat_Row1_Pos2()
	: service::Object({
		"Vehicle_Cabin_Seat_Row1_Pos2"
	}, {
		{ R"gql(heating)gql"sv, [this](service::ResolverParams&& params) { return resolveHeating(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } }
	})
{
}

service::FieldResult<std::optional<response::Value>> Vehicle_Cabin_Seat_Row1_Pos2::getHeating(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin_Seat_Row1_Pos2::getHeating is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin_Seat_Row1_Pos2::resolveHeating(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getHeating(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<response::Value>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_Cabin_Seat_Row1_Pos2::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_Cabin_Seat_Row1_Pos2)gql" }, std::move(params));
}

Vehicle_Cabin_Seat_Row2_Pos1::Vehicle_Cabin_Seat_Row2_Pos1()
	: service::Object({
		"Vehicle_Cabin_Seat_Row2_Pos1"
	}, {
		{ R"gql(heating)gql"sv, [this](service::ResolverParams&& params) { return resolveHeating(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } }
	})
{
}

service::FieldResult<std::optional<response::Value>> Vehicle_Cabin_Seat_Row2_Pos1::getHeating(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin_Seat_Row2_Pos1::getHeating is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin_Seat_Row2_Pos1::resolveHeating(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getHeating(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<response::Value>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_Cabin_Seat_Row2_Pos1::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_Cabin_Seat_Row2_Pos1)gql" }, std::move(params));
}

Vehicle_Cabin_Seat_Row2_Pos2::Vehicle_Cabin_Seat_Row2_Pos2()
	: service::Object({
		"Vehicle_Cabin_Seat_Row2_Pos2"
	}, {
		{ R"gql(heating)gql"sv, [this](service::ResolverParams&& params) { return resolveHeating(std::move(params)); } },
		{ R"gql(__typename)gql"sv, [this](service::ResolverParams&& params) { return resolve_typename(std::move(params)); } }
	})
{
}

service::FieldResult<std::optional<response::Value>> Vehicle_Cabin_Seat_Row2_Pos2::getHeating(service::FieldParams&&) const
{
	throw std::runtime_error(R"ex(Vehicle_Cabin_Seat_Row2_Pos2::getHeating is not implemented)ex");
}

std::future<service::ResolverResult> Vehicle_Cabin_Seat_Row2_Pos2::resolveHeating(service::ResolverParams&& params)
{
	std::unique_lock resolverLock(_resolverMutex);
	auto directives = std::move(params.fieldDirectives);
	auto result = getHeating(service::FieldParams(std::move(params), std::move(directives)));
	resolverLock.unlock();

	return service::ModifiedResult<response::Value>::convert<service::TypeModifier::Nullable>(std::move(result), std::move(params));
}

std::future<service::ResolverResult> Vehicle_Cabin_Seat_Row2_Pos2::resolve_typename(service::ResolverParams&& params)
{
	return service::ModifiedResult<response::StringType>::convert(response::StringType{ R"gql(Vehicle_Cabin_Seat_Row2_Pos2)gql" }, std::move(params));
}

} // namespace object

Operations::Operations(std::shared_ptr<object::Query> query, std::shared_ptr<object::Mutation> mutation, std::shared_ptr<object::Subscription> subscription)
	: service::Request({
		{ "query", query },
		{ "mutation", mutation },
		{ "subscription", subscription }
	}, GetSchema())
	, _query(std::move(query))
	, _mutation(std::move(mutation))
	, _subscription(std::move(subscription))
{
}

void AddTypesToSchema(const std::shared_ptr<schema::Schema>& schema)
{
	schema->AddType(R"gql(Int8)gql"sv, schema::ScalarType::Make(R"gql(Int8)gql"sv, R"md()md"));
	schema->AddType(R"gql(UInt8)gql"sv, schema::ScalarType::Make(R"gql(UInt8)gql"sv, R"md()md"));
	schema->AddType(R"gql(Int16)gql"sv, schema::ScalarType::Make(R"gql(Int16)gql"sv, R"md()md"));
	schema->AddType(R"gql(UInt16)gql"sv, schema::ScalarType::Make(R"gql(UInt16)gql"sv, R"md()md"));
	schema->AddType(R"gql(Int32)gql"sv, schema::ScalarType::Make(R"gql(Int32)gql"sv, R"md()md"));
	schema->AddType(R"gql(UInt32)gql"sv, schema::ScalarType::Make(R"gql(UInt32)gql"sv, R"md()md"));
	schema->AddType(R"gql(Int64)gql"sv, schema::ScalarType::Make(R"gql(Int64)gql"sv, R"md()md"));
	schema->AddType(R"gql(UInt64)gql"sv, schema::ScalarType::Make(R"gql(UInt64)gql"sv, R"md()md"));
	auto typeHasPermissionsDirectivePolicy = schema::EnumType::Make(R"gql(HasPermissionsDirectivePolicy)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(HasPermissionsDirectivePolicy)gql"sv, typeHasPermissionsDirectivePolicy);
	auto typeSubscriptionDeliveryInterval = schema::EnumType::Make(R"gql(SubscriptionDeliveryInterval)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(SubscriptionDeliveryInterval)gql"sv, typeSubscriptionDeliveryInterval);
	auto typeVehicle_Cabin_Door_Row1_Left_Input = schema::InputObjectType::Make(R"gql(Vehicle_Cabin_Door_Row1_Left_Input)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(Vehicle_Cabin_Door_Row1_Left_Input)gql"sv, typeVehicle_Cabin_Door_Row1_Left_Input);
	auto typeVehicle_Cabin_Door_Row1_Right_Input = schema::InputObjectType::Make(R"gql(Vehicle_Cabin_Door_Row1_Right_Input)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(Vehicle_Cabin_Door_Row1_Right_Input)gql"sv, typeVehicle_Cabin_Door_Row1_Right_Input);
	auto typeVehicle_Cabin_Door_Row2_Left_Input = schema::InputObjectType::Make(R"gql(Vehicle_Cabin_Door_Row2_Left_Input)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(Vehicle_Cabin_Door_Row2_Left_Input)gql"sv, typeVehicle_Cabin_Door_Row2_Left_Input);
	auto typeVehicle_Cabin_Door_Row2_Right_Input = schema::InputObjectType::Make(R"gql(Vehicle_Cabin_Door_Row2_Right_Input)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(Vehicle_Cabin_Door_Row2_Right_Input)gql"sv, typeVehicle_Cabin_Door_Row2_Right_Input);
	auto typeVehicle_Cabin_Seat_Row1_Pos1_Input = schema::InputObjectType::Make(R"gql(Vehicle_Cabin_Seat_Row1_Pos1_Input)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(Vehicle_Cabin_Seat_Row1_Pos1_Input)gql"sv, typeVehicle_Cabin_Seat_Row1_Pos1_Input);
	auto typeVehicle_Cabin_Seat_Row1_Pos2_Input = schema::InputObjectType::Make(R"gql(Vehicle_Cabin_Seat_Row1_Pos2_Input)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(Vehicle_Cabin_Seat_Row1_Pos2_Input)gql"sv, typeVehicle_Cabin_Seat_Row1_Pos2_Input);
	auto typeVehicle_Cabin_Seat_Row2_Pos1_Input = schema::InputObjectType::Make(R"gql(Vehicle_Cabin_Seat_Row2_Pos1_Input)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(Vehicle_Cabin_Seat_Row2_Pos1_Input)gql"sv, typeVehicle_Cabin_Seat_Row2_Pos1_Input);
	auto typeVehicle_Cabin_Seat_Row2_Pos2_Input = schema::InputObjectType::Make(R"gql(Vehicle_Cabin_Seat_Row2_Pos2_Input)gql"sv, R"md()md"sv);
	schema->AddType(R"gql(Vehicle_Cabin_Seat_Row2_Pos2_Input)gql"sv, typeVehicle_Cabin_Seat_Row2_Pos2_Input);
	auto typeQuery = schema::ObjectType::Make(R"gql(Query)gql"sv, R"md()md");
	schema->AddType(R"gql(Query)gql"sv, typeQuery);
	auto typeSubscription = schema::ObjectType::Make(R"gql(Subscription)gql"sv, R"md()md");
	schema->AddType(R"gql(Subscription)gql"sv, typeSubscription);
	auto typeMutation = schema::ObjectType::Make(R"gql(Mutation)gql"sv, R"md()md");
	schema->AddType(R"gql(Mutation)gql"sv, typeMutation);
	auto typeVehicle = schema::ObjectType::Make(R"gql(Vehicle)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle)gql"sv, typeVehicle);
	auto typeVehicle_Cabin = schema::ObjectType::Make(R"gql(Vehicle_Cabin)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_Cabin)gql"sv, typeVehicle_Cabin);
	auto typeVehicle_CurrentLocation = schema::ObjectType::Make(R"gql(Vehicle_CurrentLocation)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_CurrentLocation)gql"sv, typeVehicle_CurrentLocation);
	auto typeVehicle_Powertrain = schema::ObjectType::Make(R"gql(Vehicle_Powertrain)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_Powertrain)gql"sv, typeVehicle_Powertrain);
	auto typeVehicle_Cabin_Door = schema::ObjectType::Make(R"gql(Vehicle_Cabin_Door)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_Cabin_Door)gql"sv, typeVehicle_Cabin_Door);
	auto typeVehicle_Cabin_Seat = schema::ObjectType::Make(R"gql(Vehicle_Cabin_Seat)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_Cabin_Seat)gql"sv, typeVehicle_Cabin_Seat);
	auto typeVehicle_Powertrain_CombustionEngine = schema::ObjectType::Make(R"gql(Vehicle_Powertrain_CombustionEngine)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_Powertrain_CombustionEngine)gql"sv, typeVehicle_Powertrain_CombustionEngine);
	auto typeVehicle_Powertrain_FuelSystem = schema::ObjectType::Make(R"gql(Vehicle_Powertrain_FuelSystem)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_Powertrain_FuelSystem)gql"sv, typeVehicle_Powertrain_FuelSystem);
	auto typeVehicle_Powertrain_Transmission = schema::ObjectType::Make(R"gql(Vehicle_Powertrain_Transmission)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_Powertrain_Transmission)gql"sv, typeVehicle_Powertrain_Transmission);
	auto typeVehicle_Cabin_Door_Row1 = schema::ObjectType::Make(R"gql(Vehicle_Cabin_Door_Row1)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_Cabin_Door_Row1)gql"sv, typeVehicle_Cabin_Door_Row1);
	auto typeVehicle_Cabin_Door_Row2 = schema::ObjectType::Make(R"gql(Vehicle_Cabin_Door_Row2)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_Cabin_Door_Row2)gql"sv, typeVehicle_Cabin_Door_Row2);
	auto typeVehicle_Cabin_Seat_Row1 = schema::ObjectType::Make(R"gql(Vehicle_Cabin_Seat_Row1)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_Cabin_Seat_Row1)gql"sv, typeVehicle_Cabin_Seat_Row1);
	auto typeVehicle_Cabin_Seat_Row2 = schema::ObjectType::Make(R"gql(Vehicle_Cabin_Seat_Row2)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_Cabin_Seat_Row2)gql"sv, typeVehicle_Cabin_Seat_Row2);
	auto typeVehicle_Powertrain_CombustionEngine_Engine = schema::ObjectType::Make(R"gql(Vehicle_Powertrain_CombustionEngine_Engine)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_Powertrain_CombustionEngine_Engine)gql"sv, typeVehicle_Powertrain_CombustionEngine_Engine);
	auto typeVehicle_Cabin_Door_Row1_Left = schema::ObjectType::Make(R"gql(Vehicle_Cabin_Door_Row1_Left)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_Cabin_Door_Row1_Left)gql"sv, typeVehicle_Cabin_Door_Row1_Left);
	auto typeVehicle_Cabin_Door_Row1_Right = schema::ObjectType::Make(R"gql(Vehicle_Cabin_Door_Row1_Right)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_Cabin_Door_Row1_Right)gql"sv, typeVehicle_Cabin_Door_Row1_Right);
	auto typeVehicle_Cabin_Door_Row2_Left = schema::ObjectType::Make(R"gql(Vehicle_Cabin_Door_Row2_Left)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_Cabin_Door_Row2_Left)gql"sv, typeVehicle_Cabin_Door_Row2_Left);
	auto typeVehicle_Cabin_Door_Row2_Right = schema::ObjectType::Make(R"gql(Vehicle_Cabin_Door_Row2_Right)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_Cabin_Door_Row2_Right)gql"sv, typeVehicle_Cabin_Door_Row2_Right);
	auto typeVehicle_Cabin_Seat_Row1_Pos1 = schema::ObjectType::Make(R"gql(Vehicle_Cabin_Seat_Row1_Pos1)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_Cabin_Seat_Row1_Pos1)gql"sv, typeVehicle_Cabin_Seat_Row1_Pos1);
	auto typeVehicle_Cabin_Seat_Row1_Pos2 = schema::ObjectType::Make(R"gql(Vehicle_Cabin_Seat_Row1_Pos2)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_Cabin_Seat_Row1_Pos2)gql"sv, typeVehicle_Cabin_Seat_Row1_Pos2);
	auto typeVehicle_Cabin_Seat_Row2_Pos1 = schema::ObjectType::Make(R"gql(Vehicle_Cabin_Seat_Row2_Pos1)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_Cabin_Seat_Row2_Pos1)gql"sv, typeVehicle_Cabin_Seat_Row2_Pos1);
	auto typeVehicle_Cabin_Seat_Row2_Pos2 = schema::ObjectType::Make(R"gql(Vehicle_Cabin_Seat_Row2_Pos2)gql"sv, R"md()md");
	schema->AddType(R"gql(Vehicle_Cabin_Seat_Row2_Pos2)gql"sv, typeVehicle_Cabin_Seat_Row2_Pos2);

	typeHasPermissionsDirectivePolicy->AddEnumValues({
		{ service::s_namesHasPermissionsDirectivePolicy[static_cast<size_t>(vehicle::HasPermissionsDirectivePolicy::RESOLVER)], R"md()md"sv, std::nullopt },
		{ service::s_namesHasPermissionsDirectivePolicy[static_cast<size_t>(vehicle::HasPermissionsDirectivePolicy::THROW)], R"md()md"sv, std::nullopt }
	});
	typeSubscriptionDeliveryInterval->AddEnumValues({
		{ service::s_namesSubscriptionDeliveryInterval[static_cast<size_t>(vehicle::SubscriptionDeliveryInterval::DELIVERY_INTERVAL_5_SECONDS)], R"md()md"sv, std::nullopt },
		{ service::s_namesSubscriptionDeliveryInterval[static_cast<size_t>(vehicle::SubscriptionDeliveryInterval::DELIVERY_INTERVAL_1_SECOND)], R"md()md"sv, std::nullopt },
		{ service::s_namesSubscriptionDeliveryInterval[static_cast<size_t>(vehicle::SubscriptionDeliveryInterval::REALTIME)], R"md()md"sv, std::nullopt }
	});

	typeVehicle_Cabin_Door_Row1_Left_Input->AddInputValues({
		schema::InputValue::Make(R"gql(isOpen)gql"sv, R"md()md"sv, schema->LookupType("Boolean"), R"gql()gql"sv)
	});
	typeVehicle_Cabin_Door_Row1_Right_Input->AddInputValues({
		schema::InputValue::Make(R"gql(isOpen)gql"sv, R"md()md"sv, schema->LookupType("Boolean"), R"gql()gql"sv)
	});
	typeVehicle_Cabin_Door_Row2_Left_Input->AddInputValues({
		schema::InputValue::Make(R"gql(isOpen)gql"sv, R"md()md"sv, schema->LookupType("Boolean"), R"gql()gql"sv)
	});
	typeVehicle_Cabin_Door_Row2_Right_Input->AddInputValues({
		schema::InputValue::Make(R"gql(isOpen)gql"sv, R"md()md"sv, schema->LookupType("Boolean"), R"gql()gql"sv)
	});
	typeVehicle_Cabin_Seat_Row1_Pos1_Input->AddInputValues({
		schema::InputValue::Make(R"gql(heating)gql"sv, R"md()md"sv, schema->LookupType("Int8"), R"gql()gql"sv)
	});
	typeVehicle_Cabin_Seat_Row1_Pos2_Input->AddInputValues({
		schema::InputValue::Make(R"gql(heating)gql"sv, R"md()md"sv, schema->LookupType("Int8"), R"gql()gql"sv)
	});
	typeVehicle_Cabin_Seat_Row2_Pos1_Input->AddInputValues({
		schema::InputValue::Make(R"gql(heating)gql"sv, R"md()md"sv, schema->LookupType("Int8"), R"gql()gql"sv)
	});
	typeVehicle_Cabin_Seat_Row2_Pos2_Input->AddInputValues({
		schema::InputValue::Make(R"gql(heating)gql"sv, R"md()md"sv, schema->LookupType("Int8"), R"gql()gql"sv)
	});

	typeQuery->AddFields({
		schema::Field::Make(R"gql(vehicle)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle"))
	});
	typeSubscription->AddFields({
		schema::Field::Make(R"gql(vehicle)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle"), {
			schema::InputValue::Make(R"gql(deliveryInterval)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType("SubscriptionDeliveryInterval")), R"gql(DELIVERY_INTERVAL_5_SECONDS)gql"sv)
		})
	});
	typeMutation->AddFields({
		schema::Field::Make(R"gql(setVehicleCabinDoorRow1Left)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Door_Row1_Left"), {
			schema::InputValue::Make(R"gql(input)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType("Vehicle_Cabin_Door_Row1_Left_Input")), R"gql()gql"sv)
		}),
		schema::Field::Make(R"gql(setVehicleCabinDoorRow1Right)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Door_Row1_Right"), {
			schema::InputValue::Make(R"gql(input)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType("Vehicle_Cabin_Door_Row1_Right_Input")), R"gql()gql"sv)
		}),
		schema::Field::Make(R"gql(setVehicleCabinDoorRow2Left)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Door_Row2_Left"), {
			schema::InputValue::Make(R"gql(input)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType("Vehicle_Cabin_Door_Row2_Left_Input")), R"gql()gql"sv)
		}),
		schema::Field::Make(R"gql(setVehicleCabinDoorRow2Right)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Door_Row2_Right"), {
			schema::InputValue::Make(R"gql(input)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType("Vehicle_Cabin_Door_Row2_Right_Input")), R"gql()gql"sv)
		}),
		schema::Field::Make(R"gql(setVehicleCabinSeatRow1Pos1)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Seat_Row1_Pos1"), {
			schema::InputValue::Make(R"gql(input)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType("Vehicle_Cabin_Seat_Row1_Pos1_Input")), R"gql()gql"sv)
		}),
		schema::Field::Make(R"gql(setVehicleCabinSeatRow1Pos2)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Seat_Row1_Pos2"), {
			schema::InputValue::Make(R"gql(input)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType("Vehicle_Cabin_Seat_Row1_Pos2_Input")), R"gql()gql"sv)
		}),
		schema::Field::Make(R"gql(setVehicleCabinSeatRow2Pos1)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Seat_Row2_Pos1"), {
			schema::InputValue::Make(R"gql(input)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType("Vehicle_Cabin_Seat_Row2_Pos1_Input")), R"gql()gql"sv)
		}),
		schema::Field::Make(R"gql(setVehicleCabinSeatRow2Pos2)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Seat_Row2_Pos2"), {
			schema::InputValue::Make(R"gql(input)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType("Vehicle_Cabin_Seat_Row2_Pos2_Input")), R"gql()gql"sv)
		})
	});
	typeVehicle->AddFields({
		schema::Field::Make(R"gql(cabin)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin")),
		schema::Field::Make(R"gql(currentLocation)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_CurrentLocation")),
		schema::Field::Make(R"gql(powertrain)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Powertrain"))
	});
	typeVehicle_Cabin->AddFields({
		schema::Field::Make(R"gql(door)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Door")),
		schema::Field::Make(R"gql(doorCount)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("UInt8")),
		schema::Field::Make(R"gql(seat)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Seat"))
	});
	typeVehicle_CurrentLocation->AddFields({
		schema::Field::Make(R"gql(altitude)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Float")),
		schema::Field::Make(R"gql(latitude)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Float")),
		schema::Field::Make(R"gql(longitude)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Float"))
	});
	typeVehicle_Powertrain->AddFields({
		schema::Field::Make(R"gql(combustionEngine)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Powertrain_CombustionEngine")),
		schema::Field::Make(R"gql(fuelSystem)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Powertrain_FuelSystem")),
		schema::Field::Make(R"gql(transmission)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Powertrain_Transmission"))
	});
	typeVehicle_Cabin_Door->AddFields({
		schema::Field::Make(R"gql(row1)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Door_Row1")),
		schema::Field::Make(R"gql(row2)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Door_Row2"))
	});
	typeVehicle_Cabin_Seat->AddFields({
		schema::Field::Make(R"gql(row1)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Seat_Row1")),
		schema::Field::Make(R"gql(row2)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Seat_Row2"))
	});
	typeVehicle_Powertrain_CombustionEngine->AddFields({
		schema::Field::Make(R"gql(engine)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Powertrain_CombustionEngine_Engine"))
	});
	typeVehicle_Powertrain_FuelSystem->AddFields({
		schema::Field::Make(R"gql(instantConsumption)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Float")),
		schema::Field::Make(R"gql(level)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("UInt8")),
		schema::Field::Make(R"gql(tankCapacity)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Float"))
	});
	typeVehicle_Powertrain_Transmission->AddFields({
		schema::Field::Make(R"gql(currentGear)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Int8")),
		schema::Field::Make(R"gql(driveType)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("String"))
	});
	typeVehicle_Cabin_Door_Row1->AddFields({
		schema::Field::Make(R"gql(left)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Door_Row1_Left")),
		schema::Field::Make(R"gql(right)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Door_Row1_Right"))
	});
	typeVehicle_Cabin_Door_Row2->AddFields({
		schema::Field::Make(R"gql(left)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Door_Row2_Left")),
		schema::Field::Make(R"gql(right)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Door_Row2_Right"))
	});
	typeVehicle_Cabin_Seat_Row1->AddFields({
		schema::Field::Make(R"gql(pos1)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Seat_Row1_Pos1")),
		schema::Field::Make(R"gql(pos2)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Seat_Row1_Pos2"))
	});
	typeVehicle_Cabin_Seat_Row2->AddFields({
		schema::Field::Make(R"gql(pos1)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Seat_Row2_Pos1")),
		schema::Field::Make(R"gql(pos2)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Vehicle_Cabin_Seat_Row2_Pos2"))
	});
	typeVehicle_Powertrain_CombustionEngine_Engine->AddFields({
		schema::Field::Make(R"gql(speed)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("UInt16"))
	});
	typeVehicle_Cabin_Door_Row1_Left->AddFields({
		schema::Field::Make(R"gql(isOpen)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Boolean"))
	});
	typeVehicle_Cabin_Door_Row1_Right->AddFields({
		schema::Field::Make(R"gql(isOpen)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Boolean"))
	});
	typeVehicle_Cabin_Door_Row2_Left->AddFields({
		schema::Field::Make(R"gql(isOpen)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Boolean"))
	});
	typeVehicle_Cabin_Door_Row2_Right->AddFields({
		schema::Field::Make(R"gql(isOpen)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Boolean"))
	});
	typeVehicle_Cabin_Seat_Row1_Pos1->AddFields({
		schema::Field::Make(R"gql(heating)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Int8"))
	});
	typeVehicle_Cabin_Seat_Row1_Pos2->AddFields({
		schema::Field::Make(R"gql(heating)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Int8"))
	});
	typeVehicle_Cabin_Seat_Row2_Pos1->AddFields({
		schema::Field::Make(R"gql(heating)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Int8"))
	});
	typeVehicle_Cabin_Seat_Row2_Pos2->AddFields({
		schema::Field::Make(R"gql(heating)gql"sv, R"md()md"sv, std::nullopt, schema->LookupType("Int8"))
	});

	schema->AddDirective(schema::Directive::Make(R"gql(range)gql"sv, R"md()md"sv, {
		introspection::DirectiveLocation::FIELD_DEFINITION,
		introspection::DirectiveLocation::ARGUMENT_DEFINITION,
		introspection::DirectiveLocation::INPUT_FIELD_DEFINITION
	}, {
		schema::InputValue::Make(R"gql(min)gql"sv, R"md()md"sv, schema->LookupType("Float"), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(max)gql"sv, R"md()md"sv, schema->LookupType("Float"), R"gql()gql"sv)
	}));
	schema->AddDirective(schema::Directive::Make(R"gql(hasPermissions)gql"sv, R"md()md"sv, {
		introspection::DirectiveLocation::FIELD_DEFINITION,
		introspection::DirectiveLocation::OBJECT,
		introspection::DirectiveLocation::INPUT_FIELD_DEFINITION
	}, {
		schema::InputValue::Make(R"gql(permissions)gql"sv, R"md()md"sv, schema->WrapType(introspection::TypeKind::NON_NULL, schema->WrapType(introspection::TypeKind::LIST, schema->WrapType(introspection::TypeKind::NON_NULL, schema->LookupType("String")))), R"gql()gql"sv),
		schema::InputValue::Make(R"gql(policy)gql"sv, R"md()md"sv, schema->LookupType("HasPermissionsDirectivePolicy"), R"gql()gql"sv)
	}));

	schema->AddQueryType(typeQuery);
	schema->AddMutationType(typeMutation);
	schema->AddSubscriptionType(typeSubscription);
}

std::shared_ptr<schema::Schema> GetSchema()
{
	static std::weak_ptr<schema::Schema> s_wpSchema;
	auto schema = s_wpSchema.lock();

	if (!schema)
	{
		schema = std::make_shared<schema::Schema>(true);
		introspection::AddTypesToSchema(schema);
		AddTypesToSchema(schema);
		s_wpSchema = schema;
	}

	return schema;
}

} // namespace vehicle
} // namespace graphql
